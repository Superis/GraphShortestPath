Rantos-Charisopoulos Alexandros : sdi1300147@di.uoa.gr
Smyris Eleutherios : sdi1300163@di.uoa.gr
Barmpakos Periklis : sdi1300111@di.uoa.gr

## Compile

To compile run `make`

## Run

Command line options:
 * Graph : filename of Graph file 
 * Workload : filename of Workload file

Invocation:

    ./exec Graph Workload
    
## Buffer
Αυτή η δομή έχει υλοποιηθεί ως μια κλάση που περιέχει τις λίστες γειτνίασης εισερχόμενων και εξερχόμενων ακμών

## Index-Ευρετήριο
Επίσης υλοποιήθηκε ως μια κλάση η οποία αποθηκεύει ενα πίνακα από struct index_node.Ακολουθήσαμε αυτή τη λογική για να μην 
δημιουργήσουμε 2 αντίγραφα της ιδιας κλασης για εισερχομενες/εξερχομενες ακμές.Έτσι αποθηκεύουμε στην στο struct τη θέση του στοιχείου
στον πίνακα εισερχόμενων και εξερχόμενων ακμών.Επίσης έχουμε μια μεταβλητή bool init για να ξέρουμε αν έχει
αρχικοποιηθεί η εν λόγω θέση του πίνακα του ευρετηρίου.Το struct έχει έναν constructor

## Tarjan
Έχουμε ένα πίνακα από struct TarzanInfoStruct με μέγεθος όσο είναι το μέγιστο στοιχείο του γράφου.
Σε κάθε θέση του πίνακα αποθηκεύουμε την κατάσταση του κάθε κόμβου σε κάθε επίπεδο του Αλγόριθμου.
Επίσης χρησιμοποιείται και μια στοίβα όπως και στον αλγόριθμο στο wikipedia.
Αρχικά ο αλγόριθμος εκτελείται για κάθε μη αρχικοποιημένο κόμβο του γράφου.
Χρησιμοποιούμε μια while(1) loop για να προσομοιώσουμε την αναδρομή.Στην αρχή της επανάληψης
κοιτάμε αν έχουμε επισκεφτεί όλους τους γείτονες του κόμβου.Αν όχι τότε επισκεπτόμαστε αυτών που δεν
έχει αρχικοποιηθεί ακόμα και ορίζουμε σαν τωρινό κόμβο(target) αυτόν τον γείτονα και τον προσθέτουμε στην στοίβα.
Αλλιώς αν το lowlink == index τότε βρίκαμε ένα SCC και κάνουμε pop την στοίβα ώσπου ο τωρινός κόμβος να'ναι διαφορετικός
από την κεφαλή της στοίβας.Τέλος αποθηκεύουμε για κάθε κόμβο από ποιον καλέστηκε έτσι ώστε να μπορούμε 
να κάνουμε "αναδρομή" σε προηγούμενη κατάσταση/κόμβο.

## Threads
Δημιουργούμε μια ουρά από jobs στην οποια δομή αποθηκεύουμε την συνάρτηση που πρέπει να εκτελεστεί
καθώς και όλες τις πληροφορίες που χρειάζεται η συνάρτηση αυτή.Στην αρχή δημιουργούμε όσα threads είναι το 
threadpool και έπειτα όταν τελειώνει ένα σεττάρει τη μεταβλητή lastFinishedThreadID με το δικό του ΙD και
ξυπνάει τo main thread για να θέσει άλλο task σ'αυτό το νήμα.
Για τα αποτελέσματα χρησιμοποιούμε έναν δυναμικό πίνακα που ανάλογα τη σειρά του νήματος 
εκτυπώνει στην καταλληλη θέση το αποτέλεσμα της δουλειάς του.

## Unitest της Εισαγωγής
Μέσω των δομών που φτιάχτηκαν με το πρόγραμμα δημιουργούμε ένα αρχείο "graph.txt" με όλες τις εξερχόμενες ακμές κατα αύξουσα σειρά του source_id.Ουσιαστικά γίνεται ένα iterate στο ευρετήριο και εκτυπώνονται όλοι οι γείτονες του τρέχων κόμβου και αφού είναι το ευρετήριο είναι και το αρχείο.Έπειτα καλείται ένα script το οποίο  ταξινομεί το αρχικό αρχείο βάση της 1ης στήλης και τα περνάει στο αρχείο 'newSorted.txt' και έπειτα το συγκρίνει με το graph.txt.Υπάρχει πάντα μία απόκλιση/διαφορά που είναι το γράμμα S.
ΣΗΜΕΙΩΣΗ : Το script δεν είναι δυναμικό πρέπει να αλλαχθεί το file_path με το χέρι.
