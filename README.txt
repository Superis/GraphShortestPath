Rantos-Charisopoulos Alexandros : sdi1300147@di.uoa.gr
Smyris Eleutherios : sdi1300163@di.uoa.gr
Barmpakos Periklis : sdi1300111@di.uoa.gr

## Compile

To compile run `make`

## Run

Command line options:
 * Graph : path of Graph file 
 * Workload : path of Workload file

Invocation:

    ./exec Graph Workload
    
## Buffer
Αυτή η δομή έχει υλοποιηθεί ως μια κλάση που περιέχει τις λίστες γειτνίασης εισερχόμενων και εξερχόμενων ακμών

## Index-Ευρετήριο
Επίσης υλοποιήθηκε ως μια κλάση η οποία αποθηκεύει ενα πίνακα από struct index_node.Ακολουθήσαμε αυτή τη λογική για να μην 
δημιουργήσουμε 2 αντίγραφα της ιδιας κλασης για εισερχομενες/εξερχομενες ακμές.Έτσι αποθηκεύουμε στο struct τη θέση του στοιχείου
στον πίνακα εισερχόμενων και εξερχόμενων ακμών.

## Δημιουργία γράφου
Αρχικά διαβάζουμε το αρχείο για να βρούμε το μεγαλύτερο στοιχείο έτσι ώστε να δεσμεύσουμε από την αρχή σωστά το index ευρετήριο και να μην χρειαστεί 
realloc.Ουσιαστικά κάθε δυάδα αριθμών εισάγεται στο Index (αφού γίνει έλεγχος αν υπάρχουν ήδη) και η εισαγωγή στο buffer γίνεται χρησιμοποιώντας 
κέρσορες οι οποίοι δείχνουν την τελευταία θέση BLOCK(του εκάστοτε στοιχείου-out/inlast).Επίσης στην εισαγωγή κρατάμε και συνολικά τους εισερχόμενουν εξερχόμενους 
γείτονες για κάθε κόμβο στο Index.

## Tarjan
Έχουμε ένα πίνακα από struct TarzanInfoStruct με μέγεθος όσο είναι το μέγιστο στοιχείο του γράφου.
Σε κάθε θέση του πίνακα αποθηκεύουμε την κατάσταση του κάθε κόμβου σε κάθε επίπεδο του Αλγόριθμου.
Επίσης χρησιμοποιείται και μια στοίβα όπως και στον αλγόριθμο στο wikipedia.
Αρχικά ο αλγόριθμος εκτελείται για κάθε μη αρχικοποιημένο κόμβο του γράφου.
Χρησιμοποιούμε μια while(1) loop για να προσομοιώσουμε την αναδρομή.Στην αρχή της επανάληψης
κοιτάμε αν έχουμε επισκεφτεί όλους τους γείτονες του κόμβου.Αν όχι τότε επισκεπτόμαστε αυτών που δεν
έχει αρχικοποιηθεί ακόμα και ορίζουμε σαν τωρινό κόμβο(target) αυτόν τον γείτονα και τον προσθέτουμε στην στοίβα.
Αλλιώς αν το lowlink == index τότε βρίκαμε ένα SCC και κάνουμε pop την στοίβα ώσπου ο τωρινός κόμβος να'ναι διαφορετικός
από την κεφαλή της στοίβας.Τέλος αποθηκεύουμε για κάθε κόμβο από ποιον καλέστηκε έτσι ώστε να μπορούμε 
να κάνουμε "αναδρομή" σε προηγούμενη κατάσταση/κόμβο.

## Threads
Αρχικά δημιουργούμε μια κλάση JobScheduler της οποίας ο constructor δημιουργεί τα threads τα οποία
περιμένουν σε μια cond_var επειδή είναι άδεια η ουρά εργασίας είναι άδεια.
Καθώς διαβάζουμε το αρχείο δημιουργούμε μια ουρά από jobs στην οποια δομή αποθηκεύουμε την συνάρτηση που πρέπει να εκτελεστεί
καθώς και όλες τις πληροφορίες που χρειάζεται η συνάρτηση αυτή.Έπειτα σε κάθε ριπή το main thread ξυπνάει τα working threads 
και αυτά εκτελούν τις ερωτήσεις στο γράφο και περιμένει σε ενα cond_var print ώσπου να τελειώσουν.
Για τα αποτελέσματα χρησιμοποιούμε έναν δυναμικό πίνακα μέγεθος (queue_size) που ανάλογα τη σειρά του νήματος 
εκτυπώνει στην καταλληλη θέση το αποτέλεσμα της δουλειάς του.Για την εκτύπωση το τελευταίο νήμα ξυπνάει τη main για να γράψει τα
αποτελέσματα στο αρχείο.
Για τον τερματισμό των νημάτων έχουμε μια μεταβλητή finished που την θέτουμε true ξυπνάμε τα νήματα και τερματίζουν.

##Dynamic Graph

Κατ'αρχάς, για την εύρεση των weakly cc, χρησιμοποιούνται 2 ουρές(για εξερχόμενους και εισερχόμενους κόμβους) για την υλοποίηση του ΒFS στον γράφο.
Για κάθε κόμβο δηλαδή επισκέπτονται τόσο οι εξερχόμενοι από αυτόν όσο και οι εισερχόμενοι σε αυτόν κόμβοι για να διαπιστωθεί εάν ανήκουν στην ίδια συνιστώσα.
Οι πληροφορίες αυτές για τον κάθε κόμβο αποθηκεύονται στο ccindex. Έπειτα, για τη δομή του Updateindex χρησιμοποιήθηκε μία δυναμική δομή με τη μορφή πίνακα, κάθε κελί του οποίου
αποτελεί συνδεδεμένη λίστα και η θέση του οποίου στον πίνακα αναπαριστά και τον αριθμό του εκάστοτε κόμβου. 
Σε κάθε κελί αποθηκεύονται οι συνιστώσες που ενώθηκαν με το συγκεκριμένο κόμβο.Μέσω της Find_Connections γίνεται ουσιαστικά η αρχή της "αναδόμησης" του ccindex,
καθώς αυτή η συνάρτηση βρίσκει όλες τις συνιστώσες που ενώθηκαν μεταξύ τους, χρησιμοποιώντας πάλι μία ουρά σύμφωνα με την προηγούμενη λογική. Τέλος, η RebuildIndex αναλαμβάνει να αναδιοργανώσει το ccindex
με τις σωστές πλέον συνιστώσες που έχουν ενωθει. Η συνθήκη για να κληθεί η RebuildIndex βασίζεται στο metricval, του οποίου η τιμή εάν ξεπεράσει ένα κατώφλι αναδομείται το ccindex. Πρακτικά, εάν 
τα queries που χρησιμοποιούν το update index είναι τουλάχιστον τα μισά από τα συνολικά queries, καλείται η RebuildIndex και εκτελούνται τα παραπάνω.

## Unitest της Εισαγωγής
Μέσω των δομών που φτιάχτηκαν με το πρόγραμμα δημιουργούμε ένα αρχείο "graph.txt" με όλες τις εξερχόμενες ακμές κατα αύξουσα σειρά του source_id.
Ουσιαστικά γίνεται ένα iterate στο ευρετήριο και εκτυπώνονται όλοι οι γείτονες του τρέχων κόμβου και αφού είναι το ευρετήριο είναι και το αρχείο.
Έπειτα καλείται ένα script το οποίο  ταξινομεί το αρχικό αρχείο βάση της 1ης στήλης και τα περνάει στο αρχείο 'newSorted.txt' και έπειτα το συγκρίνει με το graph.txt.
Υπάρχει πάντα μία απόκλιση/διαφορά που είναι το γράμμα S.
ΣΗΜΕΙΩΣΗ : Το script δεν είναι δυναμικό πρέπει να αλλαχθεί το file_path με το χέρι.
